### 浅拷贝

重点在于`Array`和`Object`的判断，还有`typeof null`为`object`的特殊情况（`undefined`无影响）。

```javascript
function deepCopy(copy, target) {
    var target = target || {};

    for (var i in copy) {
        
        if (copy.hasOwnProperty(i)) {
        
            if (typeof copy[i] === 'object' && copy[i] !== null) {
                target[i] = copy[i].constructor === Array ? [] : {}; // Array.prototype.constructor === Array
                deepCopy(copy[i], target[i]);
            } else {
                target[i] = copy[i];
            }
            
        }
    }

    return target;
}
```

### 深拷贝

jQuery中`$.extend`没有解决自循环引用的情况，会出现爆栈。解决的方法是在复制之前检测当前是否引用自身或者任意父级。

```javascript
function DeepCopy(obj, parent = null) {
    // 创建一个新对象
    let result = {};
    let keys = Object.keys(obj),
        key = null,
        temp = null,
        _parent = parent;
    // 该字段有父级则需要追溯该字段的父级
    // 核心代码
    while (_parent) {
        // 如果该字段引用了它的父级则为循环引用
        if (_parent.originalParent === obj) {
            // 循环引用直接返回同级的新对象
            console.log(_parent.currentParent);
            return _parent.currentParent; // 返回自身的指针
        }
        _parent = _parent.parent;
    }
    for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        temp = obj[key];
        // 如果字段的值也是一个对象
        if (temp && typeof temp === 'object') {
            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用
            result[key] = DeepCopy(temp, {
                originalParent: obj,
                currentParent: result,
                parent: parent
            });
        } else {
            result[key] = temp;
        }
    }
    return result;
}
```