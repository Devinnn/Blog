> 今早阿里一面，问到`0.1 + 0.2`的问题。当然学过JavaScript的人都知道它不会等于`0.3`。面试官随即问了原理，当时我也没有接触过也不是很了解。现在就把这个知识点写成简单的博客记录，算是科普文，拓展一下知识😊。

## 十进制小数转化为二进制怎么算

十进制小数转换为二进制小数的计算：
- 取小数部分`x2`
- 取整数部分作为一个二进制位，再取小数部分`x2`，重复相同的操作
- 直到小数部分为0，结束。

```
十进制 0.1 转换成二进制
0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0
...
发现是一个无限循环小数
```

```
十进制 0.625 转换成二进制
0.625 * 2 = 1.25 # 1
0.25 * 2 = 0.5 # 0
0.5 * 2 = 1.0 # 1 // 结束
```

可以得出结论，**二进制能精确地表示位数有限且分母能表示成`2^n`的小数**。

所以，`0.1`化成二进制没有办法精确的表示出来。而`0.625`则可以。

## 精度问题

在计算机存储中，十进制的数其实是被转换成二进制来存储和操作的。

在上面其实已经发现，对于`0.1`这类的数转换成二进制是一个无限的小数，那么其实计算机内存有限，并不能存储所有的小数位数。因此，它只能在某个精度点舍弃。

于是也就有了JS计算的一个准确性问题。

## 相加计算

### 0.1 + 0.2 !== 0.3 

众所周知，JS中`0.1 + 0.2 !== 0.3`。首先，本身`0.1`在计算机内部根本就不是精确的`0.1`，而是一个有舍入误差的`0.1`。当代码被编译解释后，`0.1`已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是`0.1 + 0.2 !== 0.3`的由来。

### 0.1 + 0.1 === 0.2 

上面讲到`0.1 + 0.2 !== 0.3`，但是这里却又`0.1 + 0.1 === 0.2`。其实是两个有舍入误差的值在求和时，相互抵消了。但是这个“相互抵消”的作用不一定是可靠的。

又如`0.1 + 0.3 === 0.4`，虽然这个条件是成立的，但是实际上`0.1 + 0.3`得到的是无限接近`0.4`的值，所以直接展示或把它舍入为`0.4`。

### 0.5 + 0.625 === 1.125

上面已经说到，“二进制能精确地表示位数有限且分母能表示成`2^n`的小数”。而`0.5`和`0.625`刚好也符合这个条件，那么加起来的`1.125`自然也是符合的，也就能进行一个精确的计算。

## 注意事项

由于JS在小数计算的时候存在精度的问题，所以不要在代码中的条件判断去写浮点数的值比较，不然可能会给代码的逻辑造成不可预的逻辑错误。比如说：
```javascript
var a = 0.1;
var b = 0.2;
if (a + b === 0.3) {
    // ...
}
```

## 怎么解决精度问题

对于浮点数的运算，我们可以先把它转换成整数，得到结果后，再转换成小数。

或者使用[bignumber.js](https://github.com/MikeMcl/bignumber.js)进行运算，它在一定的精度内，让浮点数计算结果符合我们的期望。

## 总结

综上，在JavaScript中进行浮点数的计算，**绝大部分**输出的值是**不可靠**的。纵然得到的值可能是我们所预想的，但是实际上计算机所进行的计算得到的值只是无限的接近它，计算机输出的值可能只是这个真正值的一个舍入。

> 本质上，就是计算机的数字运算和存储都是会转化为二进制的，对于某些小数转换成二进制是一个无限小数，结果计算机直接截位导致精度丢失。

参考：https://segmentfault.com/a/1190000012175422